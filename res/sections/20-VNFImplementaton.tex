\chapter{Service Function Chain Implementation} 
\label{chap:vnf_ns_impl}

The complexity behind the creation of a working Service Function Chain system
was so high to require particular care and a separated study. Indeed, the SFCs
are the at the base of the whole architecture: packet transmission and
elaboration is made here. Challenges regarding this topic are building a system
that is flexible enough to allow dynamic packet routing, support scalability and
provide methods to recovery from failures. In this chapter, a brief explanation
about the challenges and the issues encountered building this system will be
given.

\section{Harbor}

As already cited, Harbor acts as a MANO, orchestrating and managing VNFs and the
related services. From the SFC point of view, it carries consistency checks when
a NS definition is created. The checks are carried out based on the VNF ID.
While the VNF definitions corresponds to a YAML Kubernetes configuration, the NS
one is a JSON array, for example:

\begin{lstlisting}[caption={Example of SFC definition}, captionpos=b,
                   language=json, label=chap:impl:lst:sfcexample]
{
    "ns" : [
                {
                    "id": "astaire-service"
                },
                ...
            ]
}
\end{lstlisting}



\section{Kubernetes Pods}

All the SFC-related components have been developed with the idea of being
containerized. This is a fundamental concept, because in this way all the
components have the possibility to run inside Kubernetes, granting them the
scalability and persistence benefits. On top of that, the use of
\verb!Deployment! granted the possibility to perform easy an update of already
existing components.

\section{Approved proposal}

\begin{figure}[t]
  \centering
  \includegraphics[width=\textwidth]{finalreview}
  \caption{Final review schema}
  \label{chap:impl:img:finalreview}
\end{figure}

The approved proposal for the creation of a proper chain has been based on four components:
\begin{itemize}
\item Astaire;
\item Harbor;
\item Ironhide;
\item Roulette.
\end{itemize}

In this context our chain has the ability to perform packet classification,
making the whole system able to separate the traffic based on a packet-type
policy. 

Another important aspect to keep in consideration is how communications inside
the chain are performed. The packet arriving in the ingress needs to be
preserved, so that VNFs can perform packet elaboration. In order to obtain this,
packet encapsulation has been used. IP in IP encapsulation allow to preserve the
original packet, making the incoming packet the payload of a new one.

Ironhide, which was introduced in the previous chapter, plays a crucial role in
the establishment of a end-to-end connection between the client and the
receiver. Ironhide is able to fulfill the ingress and the egress role, and it
provides the necessary tools to add and remove the SFC headers that gets appended
and removed.

Finally, we were able to create bidirectional chains, resistant to faults and
degradation that satisfy the defined requirements.
